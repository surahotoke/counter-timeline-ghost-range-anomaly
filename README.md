# counter-timeline-ghost-range-anomaly

## 概要

CSSの `counter`・`@counter-style`・`animation-timeline` を組み合わせた際に発生する挙動を検証したリポジトリです。

（それぞれ、***counter亡霊現象***、***range脱出現象***、***counter超亡霊現象*** と名付けた）

## 構成ファイル

- `decode.html`
- `ghost.html`
- `super-ghost.html`

## ページ

- [decode.html](https://surahotoke.github.io/counter-timeline-ghost-range-anomaly/decode.html)
- [ghost.html](https://surahotoke.github.io/counter-timeline-ghost-range-anomaly/ghost.html)
- [super-ghost.html](https://surahotoke.github.io/counter-timeline-ghost-range-anomaly/super-ghost.html)

## counterの前提知識

### 適用順

`counter-reset`, `counter-increment`, `counter-set`はプロパティ記述順に関係なくこの順番固定で適用される。

### 影響範囲

新規作成した`counter`は自身と後続兄弟要素とそれらの全ての子孫の要素、擬似要素の範囲で値を流していく。

### 各プロパティの簡単な説明

- `counter-reset`：counterの新規作成
- `counter-set`：存在するcounterの値の途中変更
- `counter-increment`：存在するcounterの値の増減
- （`set`と`increment`は`counter`が無い場合は勝手に`counter`を作る）

#### 一覧表

| | `counter-reset` | `counter-set` | `counter-increment` |
| --- | --- | --- | --- |
| 新規作成 | 常に | （無い場合） | （無い場合） |
| 値代入 | 可能 | 可能 | 不可能 |
| 値増減 | 不可能 | 不可能 | 可能 |

# decode.html

### 単体擬似要素への指定のみでheightを`<integer>`に変換する

ここで設定された値を`decode`する（自作の`symbolic`な`@counter-style`の有効範囲は`0~120`）

1行目は好きに表示できる

非常に安定しており、有効か簡単に判断できる範囲`0~120`において、`<integer>`を`<number>`に変えても正常に動作した

# ghost.html

## 【意味不明的現象】counter亡霊現象とrange脱出現象

### 観測対象

・実際に観測できるのは`re`の値
・亡霊`re`は、このバグが発生するならば存在しているはずの架空の`counter`値

### 想定される挙動

1. `--hiragana`の`range`である`1 5`を超えた場合に`reset`スタイルに移行し、`'\A'`により`--H`が`1`になる。
2. それにより、`re 1 lock 1`が発動し、`re`を範囲内の`'1'`に戻し、`lock`は`'\A'`になる。（つまり、`re`が`'\A'`になったことを`lock`に譲渡し、`re`は通常に戻る）
3. `lock`はその場定義の`counter`なので次へは引き継がれない（別階層なので）ので、次の要素では`0`にリセットされている。
4. 通常の改行なし`'1'`が次の要素に伝わるので、`counter-increment`により次の要素では`'2'`が表示される。

### 実際の挙動

1. 同じ
2. 同じ
3. 同じ
4. 工程1,2,3まで同じなのになぜか`'2'`にならず、`lock`も`re`も`1`になる状態（`counter`亡霊現象）が`range`の間だけ続く。
5. `range`を抜けた場合後、なぜか想定される挙動に戻る。（`range`脱出現象）

↓

### 回避方法！

`reset`の`range`をピッタリに設定する！（`range`で抜けるのでここを合わせると`counter`亡霊現象を回避できる）

#### 各`counter`の定義

###### lock

`re`が`--hiragana`の値の範囲を超えてリセットが発動したなら1になるcounter。`before`など見て値自体は正しいはずなのに想定される挙動とは異なる挙動をする。

###### re

メインの観測可能な`counter`で、値自体は正しいはずなのに想定される挙動とは異なる挙動をする。

###### 亡霊re

値の観測は不可能だが、発生する謎挙動から考えて存在されると仮定される謎の`counter`値

#### lock手法

1. ちょうどループを終えたタイミングで`fallback`により`--H`を`1`にすることでその情報を観測する。
2. このままでは次の要素へ渡す際にループを終えた状態であることが伝わってしまい、`increment`は`set`により毎回上書きされてしまうので、それを回避するために`--H`が`1`である情報を`lock`に譲渡させる。
3. 譲渡させるのと同時に`re`を安全圏内の`1`に設定することで、`--H`を`1`にしたまま`re`の`counter`の値を`1`へすることができる。
4. 次の要素へはループを終えた情報（`--H`が`1`である）は伝えずに、`counter`の値`1`を伝えることができる。

#### rangeと亡霊現象

`range`の範囲（`8`）を亡霊`re`カウンターの値が超えた途端謎現象から謎脱出する

↓こっちにすると`range`がピッタリ`--hiragana`の`range: 1 5;`の次の`6`までとなるので亡霊現象を回避できる！

分かりやすくするために用意したもの。これ自体は挙動への影響はない

#### 想定される挙動

```
1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5...
```

#### 実際の挙動（毎回固定）

```
1,2,3,4,5,1,1,1,2,3,4,5,1,1,1,2,3,4,5,1...
```

#### 発生条件

1つの`counter`を`lock`手法を使ってループをさせる場合
`animation-timeline`を使って出した値を`counter-set`や`counter-increment`に使ったりするとき（??）

#### ブラウザ挙動

この現象はChromeだけでなく、EdgeとOperaでも同じく発生します。
SafariとFirefoxはそもそも`animation-timeline`や`@function`などが無効なため動かないです。

# super-ghost.html

## 【超意味不明的現象】counter超亡霊現象

前回の発見により、`range`をピッタリにすることで単体`counter`では問題を回避することに成功した。複数カウンターを作り、それぞれにはその回避方法を施したものを用意する。もし、これで失敗するなら更なる解決策が必要になってくるということ。

簡単のため2種類のカウンターを使う。

- 実際に観測できるのは`re`の値

### 想定される挙動

1. `hiragana`と`katakana`でどちらのカウンターが使われているかをわかりやすくした上で、`range`を超えた場合に`reset`スタイルに移行し、`'\A\A'`により`--H`が`+2`になる。
2. それにより、`re 1 lock 1`が発動し、`re`を範囲内の`'1'`に戻し、lockは`'\A\A'`になる。
3. ついでに次のカウンター（ループ回数の異なるもの）にチェンジさせる。
4. `lock`はその場定義の`counter`なので次へは引き継がれない（別階層なので）ので、次の要素では`lock`は`0`にリセットされている。
5. 通常の改行なし`1`が次の要素に伝わるので、`counter-increment`により次の要素では`2`になり、そのまま続く。

### 実際の挙動

- とても謎になった（全然わからん）

↓

### 回避方法！

不明

#### 各`counter`の定義

###### lock

`re`が`test4`や`test13`の値の範囲を超えてリセットが発動したなら`1`になる`counter`。想定される挙動とは異なる挙動をする。

###### re

メインの観測可能な`counter`で、想定される挙動とは異なる挙動をする。

#### 観察

ここで簡単に切り替えれるので観察できる。同じように作ることでカウンターを増やして観察することも簡単。

#### 想定される挙動

```
1,2,3,4,1,2,3,4,5,6,7,8,9,10,11,12,13,1,2,3,4,1,2,3,4,5,6,7,8,9,10,11,12,13,1,2,3,4,1,2...

あいうえアイウエオカキクケコサシスあいうえアイウエオカキクケコサシスあいうえアイ...
```

#### 実際の挙動（毎回固定）

```
1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,1,2...

あいうえアイウエあいうえアイウエあいうえアあいうえアイウエあいうえアイウエあアイ...
```

#### 発生条件（最初の方だけ一応推測。何もわからない）

複数の長さの`counter`を`lock`手法で切り替えて複数種類のループをさせる場合

最初の亡霊現象はうまく抑え込めてると思いきや、実は次までは亡霊区間が続いており、その最初の亡霊区間を終えた後に次のカウンターの亡霊が生まれるみたいな（?????）

#### ブラウザ挙動

この現象はChromeだけでなく、EdgeとOperaでも同じく発生します。
SafariとFirefoxはそもそも`animation-timeline`や`@function`などが無効なため動かないです。
